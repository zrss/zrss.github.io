<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/Z.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Z.png">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.zhesih.com","root":"/","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="领略了繁华沧桑谁人过往不相似">
<meta property="og:type" content="website">
<meta property="og:title" content="随风飘散的记忆">
<meta property="og:url" content="http://blog.zhesih.com/page/7/index.html">
<meta property="og:site_name" content="随风飘散的记忆">
<meta property="og:description" content="领略了繁华沧桑谁人过往不相似">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zrss">
<meta property="article:tag" content="tech">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://blog.zhesih.com/page/7/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>随风飘散的记忆</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">随风飘散的记忆</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zrss"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Zrss</p>
  <div class="site-description" itemprop="description">领略了繁华沧桑<br>谁人过往不相似</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zrss" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zrss" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zrss" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.zhesih.com/archives/e6d66434.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Zrss">
      <meta itemprop="description" content="领略了繁华沧桑<br>谁人过往不相似">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随风飘散的记忆">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/e6d66434.html" class="post-title-link" itemprop="url">deep-in-boltdb</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-10-22 15:44:08" itemprop="dateCreated datePublished" datetime="2017-10-22T15:44:08Z">2017-10-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-12 07:12:41" itemprop="dateModified" datetime="2020-12-12T07:12:41Z">2020-12-12</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>to be cont.</p>
</blockquote>
<p>bucket -&gt; key/value</p>
<p>Cursor 是内存的概念，记录遍历到 leaf page 的路径</p>
<p>bucket 初始关联了一个 root page，为 db meta page</p>
<p>相关代码，beginTX or beginRWTx 都会有调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">init</span><span class="params">(db *DB)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	tx.root.bucket = &amp;bucket&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">	*tx.root.bucket = tx.meta.root</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 可见读事务不增加 txid，仅读写事务增加</span></span><br><span class="line">	<span class="keyword">if</span> tx.writable &#123;</span><br><span class="line">		tx.pages = <span class="built_in">make</span>(<span class="keyword">map</span>[pgid]*page)</span><br><span class="line">		tx.meta.txid += txid(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下 Cursor 的 search 实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// search recursively performs a binary search against a given page/node until it finds a given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cursor)</span> <span class="title">search</span><span class="params">(key []<span class="keyword">byte</span>, pgid pgid)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 该 pgid 可能在 page or node 中</span></span><br><span class="line">	p, n := c.bucket.pageNode(pgid)</span><br><span class="line">	<span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; (p.flags&amp;(branchPageFlag|leafPageFlag)) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;invalid page type: %d: %x&quot;</span>, p.id, p.flags))</span><br><span class="line">	&#125;</span><br><span class="line">	e := elemRef&#123;page: p, node: n&#125;</span><br><span class="line">	c.stack = <span class="built_in">append</span>(c.stack, e)</span><br><span class="line">	<span class="comment">// If we&#x27;re on a leaf page/node then find the specific node.</span></span><br><span class="line">	<span class="keyword">if</span> e.isLeaf() &#123;</span><br><span class="line">		c.nsearch(key)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.searchNode(key, n)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.searchPage(key, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page 和 node</p>
<blockquote>
<p>Once the position is found, the bucket materializes the underlying page and the page’s parent pages into memory as “nodes”</p>
</blockquote>
<p>Bucket 的数据结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bucket represents a collection of key/value pairs inside the database.</span></span><br><span class="line"><span class="keyword">type</span> Bucket <span class="keyword">struct</span> &#123;</span><br><span class="line">	*bucket</span><br><span class="line">	tx       *Tx                <span class="comment">// the associated transaction</span></span><br><span class="line">	buckets  <span class="keyword">map</span>[<span class="keyword">string</span>]*Bucket <span class="comment">// subbucket cache</span></span><br><span class="line">	page     *page              <span class="comment">// inline page reference</span></span><br><span class="line">	rootNode *node              <span class="comment">// materialized node for the root page.</span></span><br><span class="line">	nodes    <span class="keyword">map</span>[pgid]*node     <span class="comment">// node cache</span></span><br><span class="line">	<span class="comment">// Sets the threshold for filling nodes when they split. By default,</span></span><br><span class="line">	<span class="comment">// the bucket will fill to 50% but it can be useful to increase this</span></span><br><span class="line">	<span class="comment">// amount if you know that your write workloads are mostly append-only.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// This is non-persisted across transactions so it must be set in every Tx.</span></span><br><span class="line">	FillPercent <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bucket 的数据结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bucket represents the on-file representation of a bucket.</span></span><br><span class="line"><span class="comment">// This is stored as the &quot;value&quot; of a bucket key. If the bucket is small enough,</span></span><br><span class="line"><span class="comment">// then its root page can be stored inline in the &quot;value&quot;, after the bucket</span></span><br><span class="line"><span class="comment">// header. In the case of inline buckets, the &quot;root&quot; will be 0.</span></span><br><span class="line"><span class="keyword">type</span> bucket <span class="keyword">struct</span> &#123;</span><br><span class="line">	root     pgid   <span class="comment">// page id of the bucket&#x27;s root-level page</span></span><br><span class="line">	sequence <span class="keyword">uint64</span> <span class="comment">// monotonically incrementing, used by NextSequence()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续过 Cursor 的 search 实现: 根据 pageid 获取到 page 或者 node，如果是 page 类型且为 branch or leaf page 则记录到 Cursor 遍历过的 stack 中，否则 panic；node 类型直接记录；判断是否为 leaf (page or node)，是的话，在其中 nsearch(key)；nsearch 取出 stack 中最后一个 ele，如果 node 不为空，则搜索 node 中的 inode，是否存在该 key</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// 二分查找；如果没找到返回 len(n.inodes)</span></span><br><span class="line">	index := sort.Search(<span class="built_in">len</span>(n.inodes), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="comment">// &lt;</span></span><br><span class="line">		<span class="keyword">return</span> bytes.Compare(n.inodes[i].key, key) != <span class="number">-1</span></span><br><span class="line">	&#125;)</span><br><span class="line">	e.index = index</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page 类型的话，将 ptr 转换为 *[0x7FFFFFF]leafPageElement 数组，即 inodes，在其中二分搜索 key 值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inodes := p.leafPageElements()</span><br><span class="line">index := sort.Search(<span class="keyword">int</span>(p.count), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> bytes.Compare(inodes[i].key(), key) != <span class="number">-1</span></span><br><span class="line">&#125;)</span><br><span class="line">e.index = index</span><br></pre></td></tr></table></figure>

<p>如果 ele 不是 leaf 元素的话，那么只能继续从 node 中查找了 c.searchNode(key, n)</p>
<p>看到这里，记录下 node 的数据结构，越来越接近 B+ tree 的真相了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node represents an in-memory, deserialized page.</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	bucket     *Bucket</span><br><span class="line">	isLeaf     <span class="keyword">bool</span></span><br><span class="line">	unbalanced <span class="keyword">bool</span></span><br><span class="line">	spilled    <span class="keyword">bool</span></span><br><span class="line">	key        []<span class="keyword">byte</span></span><br><span class="line">	pgid       pgid</span><br><span class="line">	parent     *node</span><br><span class="line">	children   nodes</span><br><span class="line">	inodes     inodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>node 树状关系如图，直觉其中的 pgid 对应的是底层的 page，即 mmap db 文件出来的 byte[] array 中的一块</p>
<p><img src="/images/node-graph.jpeg" alt="node-graph"></p>
<p>node 的 inodes 数目存储在 page.count 中，下面的代码从 read 中摘出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read initializes the node from a page.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">read</span><span class="params">(p *page)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	n.inodes = <span class="built_in">make</span>(inodes, <span class="keyword">int</span>(p.count))</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>branchPage 中只有 key; leafPage 中有 key 和 value</p>
<p>node 中的 key 存储着其第一个 inode 的 key 值；当然如果其没有 inode 则为 nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save first key so we can find the node in the parent when we spill.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(n.inodes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">	n.key = n.inodes[<span class="number">0</span>].key</span><br><span class="line">	_assert(<span class="built_in">len</span>(n.key) &gt; <span class="number">0</span>, <span class="string">&quot;read: zero-length node key&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	n.key = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>node split，将 inodes 拆分至符合 fillPercent，parent node 的 inodes 也需要添加这些拆分出来的 nodes；还不是特别理解，这么下去的话 root node 岂不是包含所有的 inode，B+ tree 是这么设计的？还不是特别明白</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.zhesih.com/archives/ab4aa031.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Zrss">
      <meta itemprop="description" content="领略了繁华沧桑<br>谁人过往不相似">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随风飘散的记忆">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/ab4aa031.html" class="post-title-link" itemprop="url">boltdb 中的 page 回收策略及优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-10-21 15:35:21" itemprop="dateCreated datePublished" datetime="2017-10-21T15:35:21Z">2017-10-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-12 07:12:41" itemprop="dateModified" datetime="2020-12-12T07:12:41Z">2020-12-12</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><a target="_blank" rel="noopener" href="http://music.163.com/#/m/song?id=28949431">Dream Of A Dream</a> —— “人言南柯一梦，领略了繁华沧桑，谁人过往不相似”</p>
</blockquote>
<h1 id="etcd-v3-1-9-boltdb-pending-pages-回收策略"><a href="#etcd-v3-1-9-boltdb-pending-pages-回收策略" class="headerlink" title="etcd v3.1.9 boltdb pending pages 回收策略"></a>etcd v3.1.9 boltdb pending pages 回收策略</h1><p>etcdv3 中 backend 使用 boltdb 实现</p>
<p>在 etcdv3.1.9 集成的 boltdb 版本中，仅在 freelist 中记录可释放的 page id (pending: [txid] -&gt; page ids)，在 rw txn 中释放当前 txn 中最小 txid 之前的 pending pages[1]，因此如果有一个 read txn 运行时间过长，会导致部分 pages 无法及时回收使用，导致 db 大小增加。示意图如下</p>
<p><img src="/images/leak-of-pages.jpeg" alt="leak-of-pages"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">beginRWTx</span><span class="params">()</span> <span class="params">(*Tx, error)</span></span> &#123;&#125; <span class="comment">// 在该方法中释放 pending pages</span></span><br></pre></td></tr></table></figure>

<p>mock 代码也很好写，随手写了个示例 (为了效果更明显，在 tx 的 Commit 方法中输出了 freelist 的情况)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Commit</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	fmt.Printf(<span class="string">&quot;freelist pending_cnt: %d, freelist free_cnt: %d\n&quot;</span>, tx.db.freelist.pending_count(), tx.db.freelist.free_count())</span><br><span class="line">	p, err := tx.allocate((tx.db.freelist.size() / tx.db.pageSize) + <span class="number">1</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正式的 mock 代码: 在一个 read txn 中 “休息” 一会儿，同时不断的开启 rw txn 写数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/boltdb/bolt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Open the my.db data file in your current directory.</span></span><br><span class="line">	<span class="comment">// It will be created if it doesn&#x27;t exist.</span></span><br><span class="line">	db, err := bolt.Open(<span class="string">&quot;frag.db&quot;</span>, <span class="number">0600</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line">	db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		_, err := tx.CreateBucketIfNotExists([]<span class="keyword">byte</span>(<span class="string">&quot;MyBucket&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;start of long run read txn\n&quot;</span>)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;read txn txid: %d\n&quot;</span>, tx.ID())</span><br><span class="line">			bucket := tx.Bucket([]<span class="keyword">byte</span>(<span class="string">&quot;MyBucket&quot;</span>))</span><br><span class="line">			bucket.Get([]<span class="keyword">byte</span>(<span class="string">&quot;answer&quot;</span>))</span><br><span class="line">			&lt;-time.After(<span class="number">10</span> * time.Second)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;end of long run read txn\n&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;()</span><br><span class="line">	mockValue := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">64</span>; i++ &#123;</span><br><span class="line">		db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;rw txn txid: %d\n&quot;</span>, tx.ID())</span><br><span class="line">			b := tx.Bucket([]<span class="keyword">byte</span>(<span class="string">&quot;MyBucket&quot;</span>))</span><br><span class="line">			err = b.Put([]<span class="keyword">byte</span>(<span class="string">&quot;answer&quot;</span>), mockValue)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">2</span>)</span><br><span class="line">	signal.Notify(c, os.Interrupt, syscall.SIGTERM)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-c</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行三次之后，效果明显 (见如下控制台输出) ，read txn 未退出时 pending_count 增加，退出之后，free_count 总量增加，然而此时 db 文件已经扩展增大了，即总的可用页数增加了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">freelist pending_cnt: 1, freelist free_cnt: 12</span><br><span class="line">rw txn txid: 133</span><br><span class="line">freelist pending_cnt: 3, freelist free_cnt: 10</span><br><span class="line">start of long run <span class="built_in">read</span> txn</span><br><span class="line"><span class="built_in">read</span> txn txid: 132</span><br><span class="line">rw txn txid: 134</span><br><span class="line">freelist pending_cnt: 6, freelist free_cnt: 7</span><br><span class="line">rw txn txid: 135</span><br><span class="line">freelist pending_cnt: 9, freelist free_cnt: 4</span><br><span class="line">rw txn txid: 136</span><br><span class="line">freelist pending_cnt: 12, freelist free_cnt: 1</span><br><span class="line">rw txn txid: 137</span><br><span class="line">freelist pending_cnt: 15, freelist free_cnt: 0</span><br><span class="line">rw txn txid: 138</span><br><span class="line">freelist pending_cnt: 18, freelist free_cnt: 0</span><br><span class="line">rw txn txid: 139</span><br><span class="line">freelist pending_cnt: 21, freelist free_cnt: 0</span><br><span class="line">rw txn txid: 140</span><br><span class="line">freelist pending_cnt: 24, freelist free_cnt: 0</span><br><span class="line">rw txn txid: 141</span><br><span class="line">end of long run <span class="built_in">read</span> txn</span><br><span class="line">freelist pending_cnt: 27, freelist free_cnt: 0</span><br><span class="line">rw txn txid: 142</span><br><span class="line">freelist pending_cnt: 3, freelist free_cnt: 25</span><br><span class="line">rw txn txid: 143</span><br><span class="line">freelist pending_cnt: 3, freelist free_cnt: 25</span><br></pre></td></tr></table></figure>

<p>当然 long run read txn，会获取 mmap 读锁，因此当 rw txn 需要 mmap 写锁以扩大存储空间时，会阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Read-only transactions and read-write transactions should not depend on one another and generally shouldn’t be opened simultaneously in the same goroutine. This can cause a deadlock as the read-write transaction needs to periodically re-map the data file but it cannot do so while a read-only transaction is open. https:&#x2F;&#x2F;github.com&#x2F;boltdb&#x2F;bolt#transactions</span><br></pre></td></tr></table></figure>

<p>为了优化这个点儿，当然也因为 boltdb 原作者不干了，coreos 的大佬们自己拉了一个库继续搞，就是 <a target="_blank" rel="noopener" href="https://github.com/coreos/bbolt%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%96%B0%E5%BA%93%E5%9C%A8%E5%AE%83%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%90%88%E5%85%A5">https://github.com/coreos/bbolt，这个新库在它的第二个合入</a> pr <a target="_blank" rel="noopener" href="https://github.com/coreos/bbolt/pull/3">https://github.com/coreos/bbolt/pull/3</a> 中尝试解决这个问题</p>
<p>附赠一个删除 key 之后空间不会变小的解释，直觉来理解的话，boltdb 是 page 管理的空间，底层空间是连续的，boltdb 将这个空间逻辑上划分为一个个页</p>
<h1 id="bbolt-优化后的回收策略"><a href="#bbolt-优化后的回收策略" class="headerlink" title="bbolt 优化后的回收策略"></a>bbolt 优化后的回收策略</h1><p>粗略过了一遍代码，总之之前是只能释放当前最小 txn 之前的 pending pages 对吧，现在不管你，能释放的我都释放掉不就行了？示意图如下</p>
<p><img src="/images/free-pages.jpeg" alt="free-pages"></p>
<p>为了实现这个方案，当然要增加一些记录值，修改一些实现，下面详细看一下这个 pr <a target="_blank" rel="noopener" href="https://github.com/coreos/bbolt/pull/3/files">https://github.com/coreos/bbolt/pull/3/files</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// freePages releases any pages associated with closed read-only transactions.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">freePages</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Free all pending pages prior to earliest open transaction.</span></span><br><span class="line">	<span class="comment">// txid 升序排序</span></span><br><span class="line">	sort.Sort(txsById(db.txs))</span><br><span class="line">	minid := txid(<span class="number">0xFFFFFFFFFFFFFFFF</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(db.txs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		minid = db.txs[<span class="number">0</span>].meta.txid</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 释放最小 txid 之前的 pengding pages</span></span><br><span class="line">	<span class="keyword">if</span> minid &gt; <span class="number">0</span> &#123;</span><br><span class="line">		db.freelist.release(minid - <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Release unused txid extents.</span></span><br><span class="line">	<span class="comment">// 释放 tx 之间的 pending pages</span></span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> db.txs &#123;</span><br><span class="line">		db.freelist.releaseRange(minid, t.meta.txid<span class="number">-1</span>)</span><br><span class="line">		minid = t.meta.txid + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 释放当前最大 txid 之后的 pending pages</span></span><br><span class="line">	db.freelist.releaseRange(minid, txid(<span class="number">0xFFFFFFFFFFFFFFFF</span>))</span><br><span class="line">	<span class="comment">// Any page both allocated and freed in an extent is safe to release.</span></span><br><span class="line">	<span class="comment">// 假设在 rw txn 之间频繁的有 long run 的 read txn，这个优化很有效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原 freelist pending 为 [txid] -&gt; []pgid 的映射，现修改为 [txid] -&gt; txPending{} 的映射</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> txPending <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// []pgid 与 []txid 对应</span></span><br><span class="line">	<span class="comment">// 每 append 一个 pgid 则 append 一个 txid</span></span><br><span class="line">	<span class="comment">// 以记录该 pgid 是在哪个 tx 中被分配</span></span><br><span class="line">	ids              []pgid</span><br><span class="line">	alloctx          []txid <span class="comment">// txids allocating the ids</span></span><br><span class="line">	lastReleaseBegin txid   <span class="comment">// beginning txid of last matching releaseRange</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freelist 增加一个记录 allocs: map[pgid] -&gt; txid</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// freelist represents a list of all pages that are available for allocation.</span></span><br><span class="line"><span class="comment">// It also tracks pages that have been freed but are still in use by open transactions.</span></span><br><span class="line"><span class="keyword">type</span> freelist <span class="keyword">struct</span> &#123;</span><br><span class="line">	ids     []pgid              <span class="comment">// all free and available free page ids.</span></span><br><span class="line">	<span class="comment">// 记录每次 allocate 返回的 page id 与 txid 的对应关系</span></span><br><span class="line">	<span class="comment">// allocate 返回的是连续分配的第一个 page id</span></span><br><span class="line">	allocs  <span class="keyword">map</span>[pgid]txid       <span class="comment">// mapping of txid that allocated a pgid.</span></span><br><span class="line">	pending <span class="keyword">map</span>[txid]*txPending <span class="comment">// mapping of soon-to-be free page ids by tx.</span></span><br><span class="line">	cache   <span class="keyword">map</span>[pgid]<span class="keyword">bool</span>       <span class="comment">// fast lookup of all free and pending page ids.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freelist allocate 方法增加 txid 参数，用以记录 tx 分配的 page</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocate returns the starting page id of a contiguous list of pages of a given size.</span></span><br><span class="line"><span class="comment">// If a contiguous block cannot be found then 0 is returned.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *freelist)</span> <span class="title">allocate</span><span class="params">(txid txid, n <span class="keyword">int</span>)</span> <span class="title">pgid</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">			<span class="comment">// 记录；仅记录分配的连续 page 的第一个 page id</span></span><br><span class="line">			f.allocs[initial] = txid</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 freelist free 方法内部实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free releases a page and its overflow for a given transaction id.</span></span><br><span class="line"><span class="comment">// If the page is already free then a panic will occur.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *freelist)</span> <span class="title">free</span><span class="params">(txid txid, p *page)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> p.id &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;cannot free page 0 or 1: %d&quot;</span>, p.id))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Free page and all its overflow pages.</span></span><br><span class="line">	txp := f.pending[txid]</span><br><span class="line">	<span class="keyword">if</span> txp == <span class="literal">nil</span> &#123;</span><br><span class="line">		txp = &amp;txPending&#123;&#125;</span><br><span class="line">		f.pending[txid] = txp</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取是分配给哪个 tx 使用的</span></span><br><span class="line">	allocTxid, ok := f.allocs[p.id]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="comment">// 解除关联关系</span></span><br><span class="line">		<span class="built_in">delete</span>(f.allocs, p.id)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.flags &amp; (freelistPageFlag | metaPageFlag)) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Safe to claim txid as allocating since these types are private to txid.</span></span><br><span class="line">		<span class="comment">// 这两种页类型没记录</span></span><br><span class="line">		allocTxid = txid</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 释放连续页</span></span><br><span class="line">	<span class="keyword">for</span> id := p.id; id &lt;= p.id+pgid(p.overflow); id++ &#123;</span><br><span class="line">		<span class="comment">// Verify that page is not already free.</span></span><br><span class="line">		<span class="keyword">if</span> f.cache[id] &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;page %d already freed&quot;</span>, id))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Add to the freelist and cache.</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// ids 与 alloctx 对应</span></span><br><span class="line">		txp.ids = <span class="built_in">append</span>(txp.ids, id)</span><br><span class="line">		txp.alloctx = <span class="built_in">append</span>(txp.alloctx, allocTxid)</span><br><span class="line">		</span><br><span class="line">		f.cache[id] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freelist 增加 releaseRange 实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// releaseRange moves pending pages allocated within an extent [begin,end] to the free list.</span></span><br><span class="line"><span class="comment">// ps: [begin, end]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *freelist)</span> <span class="title">releaseRange</span><span class="params">(begin, end txid)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> begin &gt; end &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> m pgids</span><br><span class="line">	<span class="keyword">for</span> tid, txp := <span class="keyword">range</span> f.pending &#123;</span><br><span class="line">		<span class="keyword">if</span> tid &lt; begin || tid &gt; end &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Don&#x27;t recompute freed pages if ranges haven&#x27;t updated.</span></span><br><span class="line">		<span class="comment">// 已处理</span></span><br><span class="line">		<span class="keyword">if</span> txp.lastReleaseBegin == begin &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(txp.ids); i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> atx := txp.alloctx[i]; atx &lt; begin || atx &gt; end &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			m = <span class="built_in">append</span>(m, txp.ids[i])</span><br><span class="line">			<span class="comment">// 这个实现是够省事儿的</span></span><br><span class="line">			<span class="comment">// 如果该 page 能释放，则直接移除</span></span><br><span class="line">			<span class="comment">// ids 和 alloctx 数组前移一位</span></span><br><span class="line">			<span class="comment">// i-- 以便下次循环保持</span></span><br><span class="line">			txp.ids[i] = txp.ids[<span class="built_in">len</span>(txp.ids)<span class="number">-1</span>]</span><br><span class="line">			txp.ids = txp.ids[:<span class="built_in">len</span>(txp.ids)<span class="number">-1</span>]</span><br><span class="line">			txp.alloctx[i] = txp.alloctx[<span class="built_in">len</span>(txp.alloctx)<span class="number">-1</span>]</span><br><span class="line">			txp.alloctx = txp.alloctx[:<span class="built_in">len</span>(txp.alloctx)<span class="number">-1</span>]</span><br><span class="line">			i--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 该 txid 的 txp 在该 range 已处理</span></span><br><span class="line">		txp.lastReleaseBegin = begin</span><br><span class="line">		<span class="comment">// 如果均可以释放，则从 pending 中移除</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(txp.ids) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">delete</span>(f.pending, tid)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	sort.Sort(m)</span><br><span class="line">	<span class="comment">// 归并排序合入可用 ids</span></span><br><span class="line">	f.ids = pgids(f.ids).merge(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回过头来梳理 freelist 中的各种映射</p>
<p>pending [txid] -&gt; txPending</p>
<p>而 txPending 中又会存储 ids 和 alloctx，而看 releaseRange 中的实现，这个 alloctx 与 txid 不一定是一致的，那这个 txPending 是在哪儿修改的 ?</p>
<p><strong>问题: txPending 在哪儿被修改</strong></p>
<p>其实刚才我们已经看到了，其在 func (f *freelist) free(txid txid, p *page) 方法中被修改，那么 free 功能又是啥？</p>
<ol>
<li>free(txid txid, p *page)</li>
<li>获取 txPending (txp := f.pending[txid])</li>
<li>获取分配该 page 的 txid (allocTxid, ok := f.allocs[p.id]); 如果获取不到且 page 为 freelist or meta，将 allocTxid 设置为当前 txid</li>
<li>将释放的连续页记录到 txPending 中: txp.ids = append(txp.ids, id); txp.alloctx = append(txp.alloctx, allocTxid))</li>
</ol>
<p><strong>是否与 allocate 对应 ?</strong></p>
<ol>
<li>allocate(txid txid, n int)</li>
<li>分配连续的 n 个 pages，并返回第一个 page id (initial)</li>
<li>记录该 page id 被 txid 分配 (freelist.allocs[initial] = txid)</li>
</ol>
<p>看起来 free 并不与 allocate 对应，即并不是 free 该 txid 的所分配的 pages 的语义，而是将连续页 (p *page) 加入到 txid 的 pending 记录中待释放；这么看来的话 pending [txid] -&gt; txPending 好理解，然而 txPending 中未必只存储 [txid] 的 pending pages，这么实现应该与上层调用 free 方法的语义有关</p>
<p>最后看看 freelist 的 rollback 修改</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rollback removes the pages from a given pending tx.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *freelist)</span> <span class="title">rollback</span><span class="params">(txid txid)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Remove page ids from cache.</span></span><br><span class="line">	txp := f.pending[txid]</span><br><span class="line">	<span class="keyword">if</span> txp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> m pgids</span><br><span class="line">	<span class="keyword">for</span> i, pgid := <span class="keyword">range</span> txp.ids &#123;</span><br><span class="line">		<span class="built_in">delete</span>(f.cache, pgid)</span><br><span class="line">		tx := txp.alloctx[i]</span><br><span class="line">		<span class="comment">// tx == 0 ?!</span></span><br><span class="line">		<span class="keyword">if</span> tx == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 非当前 rollback 的 tx 分配的 page</span></span><br><span class="line">		<span class="keyword">if</span> tx != txid &#123;</span><br><span class="line">			<span class="comment">// Pending free aborted; restore page back to alloc list.</span></span><br><span class="line">			f.allocs[pgid] = tx</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Freed page was allocated by this txn; OK to throw away.</span></span><br><span class="line">			<span class="comment">// 归还 freelist ids</span></span><br><span class="line">			m = <span class="built_in">append</span>(m, pgid)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Remove pages from pending list and mark as free if allocated by txid.</span></span><br><span class="line">	<span class="built_in">delete</span>(f.pending, txid)</span><br><span class="line">	sort.Sort(m)</span><br><span class="line">	f.ids = pgids(f.ids).merge(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="更好的回收策略？"><a href="#更好的回收策略？" class="headerlink" title="更好的回收策略？"></a>更好的回收策略？</h1><p><a target="_blank" rel="noopener" href="https://github.com/coreos/bbolt/issues/14">https://github.com/coreos/bbolt/issues/14</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之这个 pr 目测能极大缓解 etcd v3.1.9 中偶尔会遇到的 mvcc: database space exceeded 的错误，但是总感觉有些 page 还是没有及时回收的样子，这种没彻底弄清楚的感觉，合入总有点儿不放心 … 随意一说</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.zhesih.com/archives/c69c7a93.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Zrss">
      <meta itemprop="description" content="领略了繁华沧桑<br>谁人过往不相似">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随风飘散的记忆">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/c69c7a93.html" class="post-title-link" itemprop="url">disk-io</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-10-21 15:34:07" itemprop="dateCreated datePublished" datetime="2017-10-21T15:34:07Z">2017-10-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-22 07:34:51" itemprop="dateModified" datetime="2020-11-22T07:34:51Z">2020-11-22</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>191</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>现在环境中 etcd 数据目录独立挂盘，看磁盘命名应该是个 lv</p>
<p>df -h 查看到类似</p>
<p>/device-mapper</p>
<p>和 lvm 相关 <a target="_blank" rel="noopener" href="https://wiki.archlinux.org/index.php/LVM">https://wiki.archlinux.org/index.php/LVM</a></p>
<p>pvs <a target="_blank" rel="noopener" href="https://linux.die.net/man/8/pvs">https://linux.die.net/man/8/pvs</a></p>
<p>iotop</p>
<p>iotop -n 1 -b -o</p>
<p>iostat</p>
<p>监控变化</p>
<p>watch -n 2 -d “xxx”</p>
<p>自动执行</p>
<p>watch -n 2 “xxx”</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.zhesih.com/archives/2121ff68.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Zrss">
      <meta itemprop="description" content="领略了繁华沧桑<br>谁人过往不相似">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随风飘散的记忆">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/2121ff68.html" class="post-title-link" itemprop="url">something-about-golang</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-10-15 23:17:02" itemprop="dateCreated datePublished" datetime="2017-10-15T23:17:02Z">2017-10-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-21 15:18:24" itemprop="dateModified" datetime="2020-11-21T15:18:24Z">2020-11-21</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>120</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Intellij-golang"><a href="#Intellij-golang" class="headerlink" title="Intellij golang"></a>Intellij golang</h1><p>用来记录一些 golang 的神奇语法及碎碎念</p>
<p>step over: 单步调试</p>
<p><strong>删除数组中的一个元素</strong></p>
<p>删除 index 元素</p>
<p>n.inodes = append(n.inodes[:index], n.inodes[index+1:]…)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.zhesih.com/archives/89164994.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Zrss">
      <meta itemprop="description" content="领略了繁华沧桑<br>谁人过往不相似">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随风飘散的记忆">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/89164994.html" class="post-title-link" itemprop="url">曾經我也想放棄治療</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-10-15 15:32:12" itemprop="dateCreated datePublished" datetime="2017-10-15T15:32:12Z">2017-10-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-22 07:32:55" itemprop="dateModified" datetime="2020-11-22T07:32:55Z">2020-11-22</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>79</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Live 版完美，温暖和力量 ——</p>
<p>曾經我也想放棄治療</p>
<p>是因為還沒遇見到你</p>
<p>像你這樣的人存在這世界上，我對世界稍微有了好感</p>
<p>像你這樣的人存在這世界上，我對世界稍微有了期待</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.zhesih.com/archives/3d903bd6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Zrss">
      <meta itemprop="description" content="领略了繁华沧桑<br>谁人过往不相似">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随风飘散的记忆">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/3d903bd6.html" class="post-title-link" itemprop="url">岁月无可回头(11)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-10-13 21:59:32" itemprop="dateCreated datePublished" datetime="2017-10-13T21:59:32Z">2017-10-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-12 07:46:24" itemprop="dateModified" datetime="2020-12-12T07:46:24Z">2020-12-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>254</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>很久没写了，这次真的情绪很低落</p>
<p>自己明明那么认真，然而却事与愿违</p>
<p>不过想想也可以理解，毕竟每个人心中重要的事情不一样，接受吧</p>
<p>是呢，工作半年，“我变强了，也变秃了”，不再是小年轻的模样，已是满脸胡须</p>
<p>年轻真好呀，可以</p>
<p>跑到海角之南，只为追一首歌的回忆</p>
<p>天不怕地不怕的闯</p>
<p>藐视一切</p>
<p>可惜，又不可惜</p>
<p>梦醒的感觉而已</p>
<p>美好又遗憾</p>
<p>2017年10月13日21:59:32 杭州</p>
<hr>
<p>三年后，此时的我，回去翻这些文字（陆陆续续写了 11 篇），只能感叹 “没有岁月可回头” ~ 希望今后有更强大的内心，去面对更多挑战</p>
<p>2020年08月01日00:47:47 杭州</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.zhesih.com/archives/77fa05dc.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Zrss">
      <meta itemprop="description" content="领略了繁华沧桑<br>谁人过往不相似">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随风飘散的记忆">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/77fa05dc.html" class="post-title-link" itemprop="url">ETCD V3 中的 db 文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-10-04 23:11:15" itemprop="dateCreated datePublished" datetime="2017-10-04T23:11:15Z">2017-10-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-12 07:12:41" itemprop="dateModified" datetime="2020-12-12T07:12:41Z">2020-12-12</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>etcd v3.1.9</p>
</blockquote>
<p>to be cont.</p>
<p>boltdb 原哥们，不维护了貌似，coreos 的人继续维护 <a target="_blank" rel="noopener" href="https://github.com/coreos/bbolt">https://github.com/coreos/bbolt</a></p>
<p>另外这个 issues 和 free page 相关，即能解决部分 boltdb 内存碎片问题</p>
<p><a target="_blank" rel="noopener" href="https://github.com/coreos/bbolt/pull/3">https://github.com/coreos/bbolt/pull/3</a></p>
<h1 id="boltdb"><a href="#boltdb" class="headerlink" title="boltdb"></a>boltdb</h1><p>bolt_unix.go 几个工具方法，如 flock / funlock / mmap / munmap</p>
<p>bolt_linux.go fsync db 文件</p>
<p>入口处在 db.go 的 Open 方法，通过 Open 方法初始化一个 db 文件；对应 etcd 中 mvcc/backend/backend.go 中的 newBackend 方法的调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newBackend</span><span class="params">(path <span class="keyword">string</span>, d time.Duration, limit <span class="keyword">int</span>)</span> *<span class="title">backend</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// bolt db</span></span><br><span class="line">	db, err := bolt.Open(path, <span class="number">0600</span>, boltOpenOptions)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		plog.Panicf(<span class="string">&quot;cannot open database at %s (%v)&quot;</span>, path, err)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Open 方法中，如果是新建的 db 文件，则调用 db.init() 写入 metadata 信息，boltdb 的注释写的很赞，感觉就是个工业又学术的艺术品，赞！</p>
<p>查看 db.init() 干了什么，直接上图吧，往 db 文件中写了四个 page （size 一般是 4096 字节） 的内容</p>
<p><img src="/images/initial_db.jpeg" alt="initial_db"></p>
<p>然后就是各种初始化了，初始化 pagePool，mmap the data file as a byte slice，初始化 freelist</p>
<p>etcd 的 InitialMmapSize 设置为 10 1024 1024 * 1024，吓人，那是否 etcd 一启动，就会占用这么大的实际内存？并不是的哈，在 mac 上实测 top 命令看到的是 314MB，ps aux 看到的 vsz 556879888，rss 476460，很好奇，按理来说 vsz 的单位应该是 kb 呀，但是这个数字有点儿大的吓人，实际应该是字节，也就是 500 多 MB，那么 rss 又怎么理解呢？rss 的单位又是 kb，实际使用了 470 多 MB？神奇，总之并不是启动之后立马占用 10 G内存</p>
<p>开头写两个一样的 meta page 貌似是为了做保护，看到 mmap 的方法中有这段注释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Validate the meta pages. We only return an error if both meta pages fail</span></span><br><span class="line"><span class="comment">// validation, since meta0 failing validation means that it wasn&#x27;t saved</span></span><br><span class="line"><span class="comment">// properly -- but we can recover using meta1. And vice-versa.</span></span><br><span class="line">err0 := db.meta0.validate()</span><br><span class="line">err1 := db.meta1.validate()</span><br><span class="line"><span class="keyword">if</span> err0 != <span class="literal">nil</span> &amp;&amp; err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说直接一点儿，boltdb 使用 mmap 把一个名为 db 的文件映射到内存中的 []byte 数组，然后直接操作内存，但是不管怎么说是外部存储，最终还是要落盘的，所以呢推测是用了 B+ tree，然后把写入的内容组织成 page，使用指针操作，这块代码有点像 C 其实</p>
<p>freelist allocate 的逻辑是从 freelist 记录的所有 free page 中分配 n 个连续的 page</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocate returns the starting page id of a contiguous list of pages of a given size.</span></span><br><span class="line"><span class="comment">// If a contiguous block cannot be found then 0 is returned.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *freelist)</span> <span class="title">allocate</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">pgid</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(f.ids) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> initial, previd pgid</span><br><span class="line">	<span class="keyword">for</span> i, id := <span class="keyword">range</span> f.ids &#123;</span><br><span class="line">		<span class="keyword">if</span> id &lt;= <span class="number">1</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;invalid page allocation: %d&quot;</span>, id))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Reset initial page if this is not contiguous.</span></span><br><span class="line">		<span class="keyword">if</span> previd == <span class="number">0</span> || id-previd != <span class="number">1</span> &#123;</span><br><span class="line">			initial = id</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If we found a contiguous block then remove it and return it.</span></span><br><span class="line">		<span class="keyword">if</span> (id-initial)+<span class="number">1</span> == pgid(n) &#123;</span><br><span class="line">			<span class="comment">// If we&#x27;re allocating off the beginning then take the fast path</span></span><br><span class="line">			<span class="comment">// and just adjust the existing slice. This will use extra memory</span></span><br><span class="line">			<span class="comment">// temporarily but the append() in free() will realloc the slice</span></span><br><span class="line">			<span class="comment">// as is necessary.</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 将已分配的连续页移出 free list 记录表 (ids)</span></span><br><span class="line">			<span class="comment">// 并释放 ids 空间</span></span><br><span class="line">			<span class="keyword">if</span> (i + <span class="number">1</span>) == n &#123;</span><br><span class="line">				f.ids = f.ids[i+<span class="number">1</span>:]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">copy</span>(f.ids[i-n+<span class="number">1</span>:], f.ids[i+<span class="number">1</span>:])</span><br><span class="line">				f.ids = f.ids[:<span class="built_in">len</span>(f.ids)-n]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Remove from the free cache.</span></span><br><span class="line">			<span class="comment">// 移出 free list cache</span></span><br><span class="line">			<span class="keyword">for</span> i := pgid(<span class="number">0</span>); i &lt; pgid(n); i++ &#123;</span><br><span class="line">				<span class="built_in">delete</span>(f.cache, initial+i)</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 返回起始页</span></span><br><span class="line">			<span class="keyword">return</span> initial</span><br><span class="line">		&#125;</span><br><span class="line">		previd = id</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freelist 的 write 实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read initializes the freelist from a freelist page.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *freelist)</span> <span class="title">read</span><span class="params">(p *page)</span></span> &#123;</span><br><span class="line">	<span class="comment">// If the page.count is at the max uint16 value (64k) then it&#x27;s considered</span></span><br><span class="line">	<span class="comment">// an overflow and the size of the freelist is stored as the first element.</span></span><br><span class="line">	idx, count := <span class="number">0</span>, <span class="keyword">int</span>(p.count)</span><br><span class="line">	<span class="keyword">if</span> count == <span class="number">0xFFFF</span> &#123;</span><br><span class="line">		idx = <span class="number">1</span></span><br><span class="line">		count = <span class="keyword">int</span>(((*[maxAllocSize]pgid)(unsafe.Pointer(&amp;p.ptr)))[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Copy the list of page ids from the freelist.</span></span><br><span class="line">	<span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">		f.ids = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ids := ((*[maxAllocSize]pgid)(unsafe.Pointer(&amp;p.ptr)))[idx:count]</span><br><span class="line">		f.ids = <span class="built_in">make</span>([]pgid, <span class="built_in">len</span>(ids))</span><br><span class="line">		<span class="built_in">copy</span>(f.ids, ids)</span><br><span class="line">		<span class="comment">// Make sure they&#x27;re sorted.</span></span><br><span class="line">		sort.Sort(pgids(f.ids))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Rebuild the page cache.</span></span><br><span class="line">	f.reindex()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freelist 的 read 实现，对应 write；如何 write 的，就如何 read</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read initializes the freelist from a freelist page.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *freelist)</span> <span class="title">read</span><span class="params">(p *page)</span></span> &#123;</span><br><span class="line">	<span class="comment">// If the page.count is at the max uint16 value (64k) then it&#x27;s considered</span></span><br><span class="line">	<span class="comment">// an overflow and the size of the freelist is stored as the first element.</span></span><br><span class="line">	<span class="comment">// page 中的 count 怎么理解 ？</span></span><br><span class="line">	<span class="comment">// 看着像是 page 下面维护着一系列 pgid</span></span><br><span class="line">	idx, count := <span class="number">0</span>, <span class="keyword">int</span>(p.count)</span><br><span class="line">	<span class="keyword">if</span> count == <span class="number">0xFFFF</span> &#123;</span><br><span class="line">		idx = <span class="number">1</span></span><br><span class="line">		count = <span class="keyword">int</span>(((*[maxAllocSize]pgid)(unsafe.Pointer(&amp;p.ptr)))[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Copy the list of page ids from the freelist.</span></span><br><span class="line">	<span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">		f.ids = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ids := ((*[maxAllocSize]pgid)(unsafe.Pointer(&amp;p.ptr)))[idx:count]</span><br><span class="line">		f.ids = <span class="built_in">make</span>([]pgid, <span class="built_in">len</span>(ids))</span><br><span class="line">		<span class="built_in">copy</span>(f.ids, ids)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// copy 结束之后，是否可以设置 ids = nil，帮助 gc ?</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Make sure they&#x27;re sorted.</span></span><br><span class="line">		sort.Sort(pgids(f.ids))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Rebuild the page cache.</span></span><br><span class="line">	f.reindex()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freelist 的 reindex 实现，其实就是构造 cache，很直接的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reindex rebuilds the free cache based on available and pending free lists.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *freelist)</span> <span class="title">reindex</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 既然已知大小的话，make 的时候为啥不指定 capacity</span></span><br><span class="line">	<span class="comment">// 好吧，我晕了，这个是 map，怎么指定大小？naive</span></span><br><span class="line">	f.cache = <span class="built_in">make</span>(<span class="keyword">map</span>[pgid]<span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, id := <span class="keyword">range</span> f.ids &#123;</span><br><span class="line">		f.cache[id] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// pending 记录了 tx 中使用过，未被释放的 page id</span></span><br><span class="line">	<span class="keyword">for</span> _, pendingIDs := <span class="keyword">range</span> f.pending &#123;</span><br><span class="line">		<span class="keyword">for</span> _, pendingID := <span class="keyword">range</span> pendingIDs &#123;</span><br><span class="line">			f.cache[pendingID] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>boltdb 在 beginRWTx 中释放空间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">beginRWTx</span><span class="params">()</span> <span class="params">(*Tx, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// If the database was opened with Options.ReadOnly, return an error.</span></span><br><span class="line">	<span class="keyword">if</span> db.readOnly &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrDatabaseReadOnly</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Obtain writer lock. This is released by the transaction when it closes.</span></span><br><span class="line">	<span class="comment">// This enforces only one writer transaction at a time.</span></span><br><span class="line">	db.rwlock.Lock()</span><br><span class="line">	<span class="comment">// Once we have the writer lock then we can lock the meta pages so that</span></span><br><span class="line">	<span class="comment">// we can set up the transaction.</span></span><br><span class="line">	db.metalock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> db.metalock.Unlock()</span><br><span class="line">	<span class="comment">// Exit if the database is not open yet.</span></span><br><span class="line">	<span class="keyword">if</span> !db.opened &#123;</span><br><span class="line">		db.rwlock.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrDatabaseNotOpen</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Create a transaction associated with the database.</span></span><br><span class="line">	t := &amp;Tx&#123;writable: <span class="literal">true</span>&#125;</span><br><span class="line">	t.init(db)</span><br><span class="line">	db.rwtx = t</span><br><span class="line">	<span class="comment">// Free any pages associated with closed read-only transactions.</span></span><br><span class="line">	<span class="comment">// 获取当前事务中的最小 txid</span></span><br><span class="line">	<span class="keyword">var</span> minid txid = <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> db.txs &#123;</span><br><span class="line">		<span class="keyword">if</span> t.meta.txid &lt; minid &#123;</span><br><span class="line">			minid = t.meta.txid</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 释放该 txid 之前的 page</span></span><br><span class="line">	<span class="keyword">if</span> minid &gt; <span class="number">0</span> &#123;</span><br><span class="line">		db.freelist.release(minid - <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 db.freelist.release 的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release moves all page ids for a transaction id (or older) to the freelist.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *freelist)</span> <span class="title">release</span><span class="params">(txid txid)</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(pgids, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> tid, ids := <span class="keyword">range</span> f.pending &#123;</span><br><span class="line">		<span class="keyword">if</span> tid &lt;= txid &#123;</span><br><span class="line">			<span class="comment">// Move transaction&#x27;s pending pages to the available freelist.</span></span><br><span class="line">			<span class="comment">// Don&#x27;t remove from the cache since the page is still free.</span></span><br><span class="line">			m = <span class="built_in">append</span>(m, ids...)</span><br><span class="line">			<span class="built_in">delete</span>(f.pending, tid)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(m)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 可重新使用的 pending page 与当前可使用的 page merge sort</span></span><br><span class="line">	f.ids = pgids(f.ids).merge(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leafPageElement 结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> leafPageElement <span class="keyword">struct</span> &#123;</span><br><span class="line">	flags <span class="keyword">uint32</span> <span class="comment">// 4 bytes; 2 leafElement / 1 branchElement / 4 meta / </span></span><br><span class="line">	pos   <span class="keyword">uint32</span> <span class="comment">// 4 bytes</span></span><br><span class="line">	ksize <span class="keyword">uint32</span> <span class="comment">// 4 bytes</span></span><br><span class="line">	vsize <span class="keyword">uint32</span> <span class="comment">// 4 bytes</span></span><br><span class="line">	<span class="comment">// pos = 16 that remain space to store key and value</span></span><br><span class="line">	<span class="comment">// for example ksize = 8 that 64 bytes for key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图所示</p>
<p><img src="/images/leafPageElement.jpeg" alt="leafPageElement"></p>
<p>即叶子节点中存储了 key 和 value</p>
<h1 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h1><p>查看 mvcc/kvstore.go 的 func (s *store) put(key, value []byte, leaseID lease.LeaseID) 方法</p>
<p>查看如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span> <span class="title">put</span><span class="params">(key, value []<span class="keyword">byte</span>, leaseID lease.LeaseID)</span></span> &#123;</span><br><span class="line">	s.txnModify = <span class="literal">true</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 每次 put revision + 1</span></span><br><span class="line">	rev := s.currentRev.main + <span class="number">1</span></span><br><span class="line">	c := rev</span><br><span class="line">	oldLease := lease.NoLease</span><br><span class="line">	<span class="comment">// if the key exists before, use its previous created and</span></span><br><span class="line">	<span class="comment">// get its previous leaseID</span></span><br><span class="line">	_, created, ver, err := s.kvindex.Get(key, rev)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		c = created.main</span><br><span class="line">		oldLease = s.le.GetLease(lease.LeaseItem&#123;Key: <span class="keyword">string</span>(key)&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// revision to bytes</span></span><br><span class="line">	ibytes := newRevBytes()</span><br><span class="line">	revToBytes(revision&#123;main: rev, sub: s.currentRev.sub&#125;, ibytes)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	ver = ver + <span class="number">1</span></span><br><span class="line">	kv := mvccpb.KeyValue&#123;</span><br><span class="line">		Key:            key,</span><br><span class="line">		Value:          value,</span><br><span class="line">		CreateRevision: c,</span><br><span class="line">		ModRevision:    rev,</span><br><span class="line">		Version:        ver,</span><br><span class="line">		Lease:          <span class="keyword">int64</span>(leaseID),</span><br><span class="line">	&#125;</span><br><span class="line">	d, err := kv.Marshal()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		plog.Fatalf(<span class="string">&quot;cannot marshal event: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// boltdb 中的 key 为 revision</span></span><br><span class="line">	<span class="comment">// value 为 mvccpb.KeyValue</span></span><br><span class="line">	<span class="comment">// 存入 boltdb 即 db 文件</span></span><br><span class="line">	s.tx.UnsafeSeqPut(keyBucketName, ibytes, d)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 存入 key -&gt; revision 的索引</span></span><br><span class="line">	s.kvindex.Put(key, revision&#123;main: rev, sub: s.currentRev.sub&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这个是啥</span></span><br><span class="line">	<span class="comment">// s.changes 什么时候释放，不然内存不会爆？</span></span><br><span class="line">	s.changes = <span class="built_in">append</span>(s.changes, kv)</span><br><span class="line">	s.currentRev.sub += <span class="number">1</span></span><br><span class="line">	<span class="comment">// lease 相关代码先略去不表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 kvindex 的实现，实际上为 newTreeIndex()，即 mvcc/index.go，摘抄一句 package 注释</p>
<p>Package btree implements in-memory B-Trees of arbitrary degree.</p>
<p>okay, index 底层是 B tree</p>
<p>查看 kvindex.put 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ti *treeIndex)</span> <span class="title">Put</span><span class="params">(key []<span class="keyword">byte</span>, rev revision)</span></span> &#123;</span><br><span class="line">	keyi := &amp;keyIndex&#123;key: key&#125;</span><br><span class="line">	ti.Lock()</span><br><span class="line">	<span class="keyword">defer</span> ti.Unlock()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// B tree get</span></span><br><span class="line">	item := ti.tree.Get(keyi)</span><br><span class="line">	<span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line">		keyi.put(rev.main, rev.sub)</span><br><span class="line">		ti.tree.ReplaceOrInsert(keyi)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// update value in B tree</span></span><br><span class="line">	okeyi := item.(*keyIndex)</span><br><span class="line">	okeyi.put(rev.main, rev.sub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kvindex 是个完全在内存中的索引，如果 etcd 重启了之后，需要恢复 kvindex 么？答案是需要的</p>
<p>etcdserver/server.go -&gt; s.kv.Restore(newbe) -&gt; func (s store) Restore(b backend.Backend) error {} -&gt; func (s store) restore() error {}</p>
<p>在最后这个方法中从 db 文件恢复 kvindex</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.zhesih.com/archives/45aaba66.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Zrss">
      <meta itemprop="description" content="领略了繁华沧桑<br>谁人过往不相似">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随风飘散的记忆">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/45aaba66.html" class="post-title-link" itemprop="url">ETCD V3 中的 Restore</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-10-04 23:07:43" itemprop="dateCreated datePublished" datetime="2017-10-04T23:07:43Z">2017-10-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-12 07:12:41" itemprop="dateModified" datetime="2020-12-12T07:12:41Z">2020-12-12</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>etcd v3.1.9</p>
</blockquote>
<p>数据是如此重要，有必要看下 etcdctl restore 的实现</p>
<p>etcdctl 的实现均在 etcdctl 目录下，ctlv2 是 v2 的实现，ctlv3 是 v3 的实现，统一入口 main.go，通过环境变量 ETCDCTL_API 指定使用哪个版本的 etcdctl</p>
<p>查看 etcdctl/ctlv3/command/snapshot_command.go 中的 snapshotRestoreCommandFunc 方法</p>
<h1 id="Restore-的整体过程"><a href="#Restore-的整体过程" class="headerlink" title="Restore 的整体过程"></a>Restore 的整体过程</h1><ol>
<li>使用 —initial-cluster / —name / —initial-cluster-token / —initial-advertise-peer-urls 参数生成 etcd 集群及成员参数</li>
<li>校验参数</li>
<li>如果 data-dir 已经存在，报错退出</li>
<li>生成 etcd v3 backend db 文件 (makeDB)</li>
<li>生成 .wal 和 .snap 文件 (makeWALAndSnap)</li>
</ol>
<h1 id="makeDB"><a href="#makeDB" class="headerlink" title="makeDB"></a>makeDB</h1><p>具体查看 makeDB 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makeDB copies the database snapshot to the snapshot directory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeDB</span><span class="params">(snapdir, dbfile <span class="keyword">string</span>, commit <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开 db 文件</span></span><br><span class="line">	f, ferr := os.OpenFile(dbfile, os.O_RDONLY, <span class="number">0600</span>)</span><br><span class="line">	<span class="keyword">if</span> ferr != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitInvalidInput, ferr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="comment">// get snapshot integrity hash</span></span><br><span class="line">	<span class="keyword">if</span> _, err := f.Seek(-sha256.Size, os.SEEK_END); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitIO, err)</span><br><span class="line">	&#125;</span><br><span class="line">	sha := <span class="built_in">make</span>([]<span class="keyword">byte</span>, sha256.Size)</span><br><span class="line">	<span class="keyword">if</span> _, err := f.Read(sha); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitIO, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, err := f.Seek(<span class="number">0</span>, os.SEEK_SET); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitIO, err)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建 data-dir/member/snap 目录</span></span><br><span class="line">	<span class="keyword">if</span> err := fileutil.CreateDirAll(snapdir); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitIO, err)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 拷贝 db 文件至 data-dir/member/snap/db</span></span><br><span class="line">	dbpath := filepath.Join(snapdir, <span class="string">&quot;db&quot;</span>)</span><br><span class="line">	db, dberr := os.OpenFile(dbpath, os.O_RDWR|os.O_CREATE, <span class="number">0600</span>)</span><br><span class="line">	<span class="keyword">if</span> dberr != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitIO, dberr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, err := io.Copy(db, f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitIO, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// truncate away integrity hash, if any.</span></span><br><span class="line">	off, serr := db.Seek(<span class="number">0</span>, os.SEEK_END)</span><br><span class="line">	<span class="keyword">if</span> serr != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitIO, serr)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// db 文件中是否存在 hash 值这块有点意思</span></span><br><span class="line">	<span class="comment">// 看着是以 512 chunk 的方式写入的</span></span><br><span class="line">	<span class="comment">// % 512 以后余下的字节数等于 sha256.Size 的话</span></span><br><span class="line">	<span class="comment">// 那么 db 文件存在 hash 值</span></span><br><span class="line">	hasHash := (off % <span class="number">512</span>) == sha256.Size</span><br><span class="line">	<span class="keyword">if</span> hasHash &#123;</span><br><span class="line">		<span class="comment">// 去掉 db 文件末尾的 hash 值</span></span><br><span class="line">		<span class="keyword">if</span> err := db.Truncate(off - sha256.Size); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			ExitWithError(ExitIO, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果既没有 hash 值，restore 参数又没有指定 --skip-hash-check</span></span><br><span class="line">	<span class="comment">// 那么报错退出</span></span><br><span class="line">	<span class="comment">// 注意此时已经生成了 data-dir/member/snap/db 文件</span></span><br><span class="line">	<span class="keyword">if</span> !hasHash &amp;&amp; !skipHashCheck &#123;</span><br><span class="line">		err := fmt.Errorf(<span class="string">&quot;snapshot missing hash but --skip-hash-check=false&quot;</span>)</span><br><span class="line">		ExitWithError(ExitBadArgs, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> hasHash &amp;&amp; !skipHashCheck &#123;</span><br><span class="line">		<span class="comment">// check for match</span></span><br><span class="line">		<span class="keyword">if</span> _, err := db.Seek(<span class="number">0</span>, os.SEEK_SET); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			ExitWithError(ExitIO, err)</span><br><span class="line">		&#125;</span><br><span class="line">		h := sha256.New()</span><br><span class="line">		<span class="keyword">if</span> _, err := io.Copy(h, db); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			ExitWithError(ExitIO, err)</span><br><span class="line">		&#125;</span><br><span class="line">		dbsha := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> !reflect.DeepEqual(sha, dbsha) &#123;</span><br><span class="line">			err := fmt.Errorf(<span class="string">&quot;expected sha256 %v, got %v&quot;</span>, sha, dbsha)</span><br><span class="line">			ExitWithError(ExitInvalidInput, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// db hash is OK, can now modify DB so it can be part of a new cluster</span></span><br><span class="line">	db.Close()</span><br><span class="line">	<span class="comment">// update consistentIndex so applies go through on etcdserver despite</span></span><br><span class="line">	<span class="comment">// having a new raft instance</span></span><br><span class="line">	be := backend.NewDefaultBackend(dbpath)</span><br><span class="line">	<span class="comment">// a lessor never timeouts leases</span></span><br><span class="line">	lessor := lease.NewLessor(be, math.MaxInt64)</span><br><span class="line">	s := mvcc.NewStore(be, lessor, (*initIndex)(&amp;commit))</span><br><span class="line">	id := s.TxnBegin()</span><br><span class="line">	btx := be.BatchTx()</span><br><span class="line">	del := <span class="function"><span class="keyword">func</span><span class="params">(k, v []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		_, _, err := s.TxnDeleteRange(id, k, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// db 文件中存储了 member 的信息</span></span><br><span class="line">	<span class="comment">// 此处删除</span></span><br><span class="line">	<span class="comment">// delete stored members from old cluster since using new members</span></span><br><span class="line">	btx.UnsafeForEach([]<span class="keyword">byte</span>(<span class="string">&quot;members&quot;</span>), del)</span><br><span class="line">	<span class="comment">// todo: add back new members when we start to deprecate old snap file.</span></span><br><span class="line">	btx.UnsafeForEach([]<span class="keyword">byte</span>(<span class="string">&quot;members_removed&quot;</span>), del)</span><br><span class="line">	<span class="comment">// trigger write-out of new consistent index</span></span><br><span class="line">	s.TxnEnd(id)</span><br><span class="line">	s.Commit()</span><br><span class="line">	s.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="makeWALAndSnap"><a href="#makeWALAndSnap" class="headerlink" title="makeWALAndSnap"></a>makeWALAndSnap</h1><p>具体查看 makeWALAndSnap 方法，无图言 x，makeWALAndSnap 生成的 .wal 和 .snap 文件内容如下</p>
<p><img src="/images/restore_wal.jpeg" alt="restore_wal"></p>
<p>代码注释如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makeWAL creates a WAL for the initial cluster</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeWALAndSnap</span><span class="params">(waldir, snapdir <span class="keyword">string</span>, cl *membership.RaftCluster)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 新建 data-dir/member/wal 目录</span></span><br><span class="line">	<span class="keyword">if</span> err := fileutil.CreateDirAll(waldir); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitIO, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// etcd v2 storage</span></span><br><span class="line">	<span class="comment">// add members again to persist them to the store we create.</span></span><br><span class="line">	st := store.New(etcdserver.StoreClusterPrefix, etcdserver.StoreKeysPrefix)</span><br><span class="line">	cl.SetStore(st)</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> cl.Members() &#123;</span><br><span class="line">		cl.AddMember(m)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cluster and member metadata</span></span><br><span class="line">	<span class="comment">// write to wal</span></span><br><span class="line">	m := cl.MemberByName(restoreName)</span><br><span class="line">	md := &amp;etcdserverpb.Metadata&#123;NodeID: <span class="keyword">uint64</span>(m.ID), ClusterID: <span class="keyword">uint64</span>(cl.ID())&#125;</span><br><span class="line">	metadata, merr := md.Marshal()</span><br><span class="line">	<span class="keyword">if</span> merr != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitInvalidInput, merr)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 生成初始 wal 文件</span></span><br><span class="line">	w, walerr := wal.Create(waldir, metadata)</span><br><span class="line">	<span class="keyword">if</span> walerr != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitIO, walerr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> w.Close()</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// add entries for raft start</span></span><br><span class="line">	peers := <span class="built_in">make</span>([]raft.Peer, <span class="built_in">len</span>(cl.MemberIDs()))</span><br><span class="line">	<span class="keyword">for</span> i, id := <span class="keyword">range</span> cl.MemberIDs() &#123;</span><br><span class="line">		ctx, err := json.Marshal((*cl).Member(id))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			ExitWithError(ExitInvalidInput, err)</span><br><span class="line">		&#125;</span><br><span class="line">		peers[i] = raft.Peer&#123;ID: <span class="keyword">uint64</span>(id), Context: ctx&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ents := <span class="built_in">make</span>([]raftpb.Entry, <span class="built_in">len</span>(peers))</span><br><span class="line">	nodeIDs := <span class="built_in">make</span>([]<span class="keyword">uint64</span>, <span class="built_in">len</span>(peers))</span><br><span class="line">	<span class="keyword">for</span> i, p := <span class="keyword">range</span> peers &#123;</span><br><span class="line">		nodeIDs[i] = p.ID</span><br><span class="line">		cc := raftpb.ConfChange&#123;</span><br><span class="line">			Type:    raftpb.ConfChangeAddNode,</span><br><span class="line">			NodeID:  p.ID,</span><br><span class="line">			Context: p.Context&#125;</span><br><span class="line">		d, err := cc.Marshal()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			ExitWithError(ExitInvalidInput, err)</span><br><span class="line">		&#125;</span><br><span class="line">		e := raftpb.Entry&#123;</span><br><span class="line">			Type:  raftpb.EntryConfChange,</span><br><span class="line">			Term:  <span class="number">1</span>,</span><br><span class="line">			Index: <span class="keyword">uint64</span>(i + <span class="number">1</span>),</span><br><span class="line">			Data:  d,</span><br><span class="line">		&#125;</span><br><span class="line">		ents[i] = e</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// add nodes entries are committed</span></span><br><span class="line">	<span class="comment">// initial term 1</span></span><br><span class="line">	<span class="comment">// save to wal</span></span><br><span class="line">	commit, term := <span class="keyword">uint64</span>(<span class="built_in">len</span>(ents)), <span class="keyword">uint64</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> err := w.Save(raftpb.HardState&#123;</span><br><span class="line">		Term:   term,</span><br><span class="line">		Vote:   peers[<span class="number">0</span>].ID,</span><br><span class="line">		Commit: commit&#125;, ents); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitIO, err)</span><br><span class="line">	&#125;</span><br><span class="line">	b, berr := st.Save()</span><br><span class="line">	<span class="keyword">if</span> berr != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitError, berr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// first snapshot</span></span><br><span class="line">	raftSnap := raftpb.Snapshot&#123;</span><br><span class="line">		Data: b,</span><br><span class="line">		Metadata: raftpb.SnapshotMetadata&#123;</span><br><span class="line">			Index: commit,</span><br><span class="line">			Term:  term,</span><br><span class="line">			ConfState: raftpb.ConfState&#123;</span><br><span class="line">				Nodes: nodeIDs,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// save snapshot</span></span><br><span class="line">	<span class="comment">// Term: 1</span></span><br><span class="line">	<span class="comment">// Index: The number of member in cluster</span></span><br><span class="line">	snapshotter := snap.New(snapdir)</span><br><span class="line">	<span class="keyword">if</span> err := snapshotter.SaveSnap(raftSnap); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// write to wal</span></span><br><span class="line">	<span class="keyword">if</span> err := w.SaveSnapshot(walpb.Snapshot&#123;Index: commit, Term: term&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ExitWithError(ExitIO, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.zhesih.com/archives/3869686e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Zrss">
      <meta itemprop="description" content="领略了繁华沧桑<br>谁人过往不相似">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随风飘散的记忆">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/3869686e.html" class="post-title-link" itemprop="url">ETCD V3 如何完成一次 put 请求</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-10-04 23:00:55" itemprop="dateCreated datePublished" datetime="2017-10-04T23:00:55Z">2017-10-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-21 15:06:26" itemprop="dateModified" datetime="2020-11-21T15:06:26Z">2020-11-21</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>etcd 完成一次写入需要经过哪些过程？</p>
<p>implementation of put grpc request</p>
<p>key.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *kvServer)</span> <span class="title">Put</span><span class="params">(ctx context.Context, r *pb.PutRequest)</span> <span class="params">(*pb.PutResponse, error)</span></span></span><br></pre></td></tr></table></figure>

<p>v3_server.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span> <span class="title">Put</span><span class="params">(ctx context.Context, r *pb.PutRequest)</span> <span class="params">(*pb.PutResponse, error)</span></span></span><br></pre></td></tr></table></figure>

<p>v3_server.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span> <span class="title">processInternalRaftRequest</span><span class="params">(ctx context.Context, r pb.InternalRaftRequest)</span> <span class="params">(*applyResult, error)</span></span></span><br></pre></td></tr></table></figure>

<p>v3_server.go</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (s *EtcdServer) processInternalRaftRequestOnce(ctx context.Context, r pb.InternalRaftRequest) (*applyResult, error)</span><br></pre></td></tr></table></figure>

<p>注册一个等待 id；完成之后调用 s.w.Trigger 触发完成 or GC<br>ch := s.w.Register(id)</p>
<p>raft propose (提议写入数据)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// propose PutRequest</span></span><br><span class="line">s.r.Propose(cctx, data)</span><br></pre></td></tr></table></figure>

<p>node.go</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (n *node) Propose(ctx context.Context, data []byte) error</span><br></pre></td></tr></table></figure>

<p>n.step 往 propc 通道传入数据</p>
<p>node run main roop</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">run</span><span class="params">(r *raft)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">		<span class="keyword">case</span> m := &lt;-propc:</span><br><span class="line">			r.logger.Infof(<span class="string">&quot;handle propc message&quot;</span>)</span><br><span class="line">			m.From = r.id</span><br><span class="line">			r.Step(m)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>raft/raft.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *raft)</span> <span class="title">Step</span><span class="params">(m pb.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		r.step(r, m)</span><br><span class="line">  </span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>r.step(r, m)</p>
<p>leader 和 follower 行为不同</p>
<p>对于 follower 来说</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepFollower</span><span class="params">(r *raft, m pb.Message)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">case</span> pb.MsgProp:</span><br><span class="line">		<span class="keyword">if</span> r.lead == None &#123;</span><br><span class="line">			r.logger.Infof(<span class="string">&quot;%x no leader at term %d; dropping proposal&quot;</span>, r.id, r.Term)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// forward to leader</span></span><br><span class="line">		m.To = r.lead</span><br><span class="line">		<span class="comment">// just append to raft pb.Message ?</span></span><br><span class="line">		r.send(m)</span><br><span class="line">    </span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>r.send(m) 只是把 message append 到 raft/raft.go 的 msgs []pb.Message 数组中，谁去消费这个 message ？</p>
<p>node.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newReady</span><span class="params">(r *raft, prevSoftSt *SoftState, prevHardSt pb.HardState)</span> <span class="title">Ready</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    rd := Ready&#123;</span><br><span class="line">		Entries:          r.raftLog.unstableEntries(),</span><br><span class="line">		CommittedEntries: r.raftLog.nextEnts(),</span><br><span class="line">		Messages:         r.msgs,</span><br><span class="line">	&#125;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ready 又是由谁消费的？</p>
<p>node.go main roop</p>
<p>func (n node) run(r raft)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">run</span><span class="params">(r *raft)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">		<span class="keyword">if</span> advancec != <span class="literal">nil</span> &#123;</span><br><span class="line">			readyc = <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			rd = newReady(r, prevSoftSt, prevHardSt)</span><br><span class="line">			<span class="keyword">if</span> rd.containsUpdates() &#123;</span><br><span class="line">				readyc = n.readyc</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				readyc = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">case</span> readyc &lt;- rd:</span><br><span class="line">                  r.logger.Infof(<span class="string">&quot;handle ready&quot;</span>)</span><br><span class="line">                  <span class="keyword">if</span> rd.SoftState != <span class="literal">nil</span> &#123;</span><br><span class="line">                      prevSoftSt = rd.SoftState</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> <span class="built_in">len</span>(rd.Entries) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                      prevLastUnstablei = rd.Entries[<span class="built_in">len</span>(rd.Entries)<span class="number">-1</span>].Index</span><br><span class="line">                      prevLastUnstablet = rd.Entries[<span class="built_in">len</span>(rd.Entries)<span class="number">-1</span>].Term</span><br><span class="line">                      havePrevLastUnstablei = <span class="literal">true</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> !IsEmptyHardState(rd.HardState) &#123;</span><br><span class="line">                      prevHardSt = rd.HardState</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> !IsEmptySnap(rd.Snapshot) &#123;</span><br><span class="line">                      prevSnapi = rd.Snapshot.Metadata.Index</span><br><span class="line">                  &#125;</span><br><span class="line">                  r.msgs = <span class="literal">nil</span></span><br><span class="line">                  r.readStates = <span class="literal">nil</span></span><br><span class="line">                  advancec = n.advancec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readyc 又由谁消费呢？</p>
<p>实际上 readyc 是 n.readyc，所以找下 n.readyc 由谁消费即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type node struct &#123;</span><br><span class="line">	...</span><br><span class="line">	readyc     chan Ready</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">func (n *node) Ready() &lt;-chan Ready &#123; return n.readyc &#125;</span><br></pre></td></tr></table></figure>

<p>所以我们继续追寻哪里取了 Ready() 通道</p>
<p>终于在</p>
<p>etcdserver/raft.go 中发现了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *raftNode)</span> <span class="title">start</span><span class="params">(rh *raftReadyHandler)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> rd := &lt;-r.Ready():</span><br><span class="line">				<span class="keyword">if</span> rd.SoftState != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="comment">// lead has changed</span></span><br><span class="line">					<span class="keyword">if</span> lead := atomic.LoadUint64(&amp;r.lead); rd.SoftState.Lead != raft.None &amp;&amp; lead != rd.SoftState.Lead &#123;</span><br><span class="line">						r.mu.Lock()</span><br><span class="line">						r.lt = time.Now()</span><br><span class="line">						r.mu.Unlock()</span><br><span class="line">						<span class="comment">// prometheus record the count of leader changes</span></span><br><span class="line">						leaderChanges.Inc()</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> rd.SoftState.Lead == raft.None &#123;</span><br><span class="line">						hasLeader.Set(<span class="number">0</span>)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						hasLeader.Set(<span class="number">1</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// store current seen leader</span></span><br><span class="line">					atomic.StoreUint64(&amp;r.lead, rd.SoftState.Lead)</span><br><span class="line">					islead = rd.RaftState == raft.StateLeader</span><br><span class="line">					<span class="comment">// raft handler</span></span><br><span class="line">					rh.updateLeadership()</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(rd.ReadStates) != <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> r.readStateC &lt;- rd.ReadStates[<span class="built_in">len</span>(rd.ReadStates)<span class="number">-1</span>]:</span><br><span class="line">					<span class="keyword">case</span> &lt;-time.After(internalTimeout):</span><br><span class="line">						plog.Warningf(<span class="string">&quot;timed out sending read state&quot;</span>)</span><br><span class="line">					<span class="keyword">case</span> &lt;-r.stopped:</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				raftDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">				ap := apply&#123;</span><br><span class="line">					entries:  rd.CommittedEntries,</span><br><span class="line">					snapshot: rd.Snapshot,</span><br><span class="line">					raftDone: raftDone,</span><br><span class="line">				&#125;</span><br><span class="line">				updateCommittedIndex(&amp;ap, rh)</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> r.applyc &lt;- ap:</span><br><span class="line">				<span class="keyword">case</span> &lt;-r.stopped:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// the leader can write to its disk in parallel with replicating to the followers and them</span></span><br><span class="line">				<span class="comment">// writing to their disks.</span></span><br><span class="line">				<span class="comment">// For more details, check raft thesis 10.2.1</span></span><br><span class="line">				<span class="keyword">if</span> islead &#123;</span><br><span class="line">					<span class="comment">// gofail: var raftBeforeLeaderSend struct&#123;&#125;</span></span><br><span class="line">					r.sendMessages(rd.Messages)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// gofail: var raftBeforeSave struct&#123;&#125;</span></span><br><span class="line">				<span class="keyword">if</span> err := r.storage.Save(rd.HardState, rd.Entries); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					plog.Fatalf(<span class="string">&quot;raft save state and entries error: %v&quot;</span>, err)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> !raft.IsEmptyHardState(rd.HardState) &#123;</span><br><span class="line">					proposalsCommitted.Set(<span class="keyword">float64</span>(rd.HardState.Commit))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// gofail: var raftAfterSave struct&#123;&#125;</span></span><br><span class="line">				<span class="keyword">if</span> !raft.IsEmptySnap(rd.Snapshot) &#123;</span><br><span class="line">					<span class="comment">// gofail: var raftBeforeSaveSnap struct&#123;&#125;</span></span><br><span class="line">					<span class="keyword">if</span> err := r.storage.SaveSnap(rd.Snapshot); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						plog.Fatalf(<span class="string">&quot;raft save snapshot error: %v&quot;</span>, err)</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// gofail: var raftAfterSaveSnap struct&#123;&#125;</span></span><br><span class="line">					r.raftStorage.ApplySnapshot(rd.Snapshot)</span><br><span class="line">					plog.Infof(<span class="string">&quot;raft applied incoming snapshot at index %d&quot;</span>, rd.Snapshot.Metadata.Index)</span><br><span class="line">					<span class="comment">// gofail: var raftAfterApplySnap struct&#123;&#125;</span></span><br><span class="line">				&#125;</span><br><span class="line">				r.raftStorage.Append(rd.Entries)</span><br><span class="line">				<span class="keyword">if</span> !islead &#123;</span><br><span class="line">					<span class="comment">// gofail: var raftBeforeFollowerSend struct&#123;&#125;</span></span><br><span class="line">					r.sendMessages(rd.Messages)</span><br><span class="line">				&#125;</span><br><span class="line">				raftDone &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">				r.Advance()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该部分会将 apply 的 message 放入 applc 通道中，最终由</p>
<p>server.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> ap := &lt;-s.r.apply():</span><br><span class="line">			f := <span class="function"><span class="keyword">func</span><span class="params">(context.Context)</span></span> &#123; s.applyAll(&amp;ep, &amp;ap) &#125;</span><br><span class="line">			sched.Schedule(f)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做持久化，并且 trigger 写入结束</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.zhesih.com/archives/8cdb9b5c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Zrss">
      <meta itemprop="description" content="领略了繁华沧桑<br>谁人过往不相似">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随风飘散的记忆">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/8cdb9b5c.html" class="post-title-link" itemprop="url">ETCD V3 中的 .wal 文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-10-03 22:50:39" itemprop="dateCreated datePublished" datetime="2017-10-03T22:50:39Z">2017-10-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-12 07:12:41" itemprop="dateModified" datetime="2020-12-12T07:12:41Z">2020-12-12</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>etcd v3.1.9</p>
</blockquote>
<p>.wal 文件，即 write ahead log，wal 的实现集中在 wal 目录下</p>
<h1 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h1><p>其中 wal/walpb 目录下定义了 wal 中记录的两种消息类型： Record 和 Snapshot</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message Record &#123;</span><br><span class="line">	optional int64 type  &#x3D; 1 [(gogoproto.nullable) &#x3D; false];</span><br><span class="line">	optional uint32 crc  &#x3D; 2 [(gogoproto.nullable) &#x3D; false];</span><br><span class="line">	optional bytes data  &#x3D; 3;</span><br><span class="line">&#125;</span><br><span class="line">message Snapshot &#123;</span><br><span class="line">	optional uint64 index &#x3D; 1 [(gogoproto.nullable) &#x3D; false];</span><br><span class="line">	optional uint64 term  &#x3D; 2 [(gogoproto.nullable) &#x3D; false];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 pb 比较省事儿，不用自己实现对象序列化反序列化的逻辑</p>
<h1 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h1><p>wal 有两个方法会创建 wal 文件，一个是 Create 方法，另一个是 cut 方法<br>Create 方法会创建初始 wal 文件，名称为 0000000000000000-0000000000000000.wal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p :&#x3D; filepath.Join(tmpdirpath, walName(0, 0))</span><br></pre></td></tr></table></figure>

<p>查看 Create 创建初始 wal 文件的过程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keep temporary wal directory so WAL initialization appears atomic</span></span><br><span class="line">tmpdirpath := filepath.Clean(dirpath) + <span class="string">&quot;.tmp&quot;</span></span><br><span class="line"><span class="comment">// 生成初始 wal 文件名</span></span><br><span class="line">p := filepath.Join(tmpdirpath, walName(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment">// 系统调用 LockFile</span></span><br><span class="line"><span class="comment">// 防止被 purge</span></span><br><span class="line">f, err := fileutil.LockFile(p, os.O_WRONLY|os.O_CREATE, fileutil.PrivateFileMode)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不是很理解这个地方为何要 seek 到文件末尾</span></span><br><span class="line"><span class="keyword">if</span> _, err = f.Seek(<span class="number">0</span>, os.SEEK_END); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预分配 wal 文件空间</span></span><br><span class="line"><span class="comment">// SegmentSizeBytes = 64 * 1024 * 1024</span></span><br><span class="line"><span class="comment">// 即 64 MB</span></span><br><span class="line"><span class="keyword">if</span> err = fileutil.Preallocate(f.File, SegmentSizeBytes, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 将 wal 文件加入 locks slice 中</span></span><br><span class="line">w.locks = <span class="built_in">append</span>(w.locks, f)</span><br><span class="line"><span class="comment">// 写入初始信息 ...</span></span><br><span class="line"><span class="keyword">if</span> w, err = w.renameWal(tmpdirpath); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>w.renameWal(tmpdirpath) 值得抽出来说下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除原 wal path</span></span><br><span class="line"><span class="keyword">if</span> err := os.RemoveAll(w.dir); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 tmp wal path -&gt; wal path</span></span><br><span class="line"><span class="keyword">if</span> err := os.Rename(tmpdirpath, w.dir); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这里初始化 FilePipeline</span></span><br><span class="line">w.fp = newFilePipeline(w.dir, SegmentSizeBytes)</span><br><span class="line">df, err := fileutil.OpenDir(w.dir)</span><br><span class="line">w.dirFile = df</span><br><span class="line"><span class="keyword">return</span> w, err</span><br></pre></td></tr></table></figure>

<p>初始写入 wal 内容示意如下</p>
<p><img src="/images/initial_wal.jpg" alt="initial_wal"></p>
<h1 id="预分配空间"><a href="#预分配空间" class="headerlink" title="预分配空间"></a>预分配空间</h1><p>在 unix OS 上，首先会使用系统调用 Fallocate 预分配文件空间</p>
<p>如果 Fallocate 失败，则 fallback 到 preallocExtendTrunc 再次尝试分配</p>
<p>查看 preallocExtendTrunc 的逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动到文件的当前读写位置，返回 offset</span></span><br><span class="line"><span class="comment">// 一般 curOff = 0</span></span><br><span class="line">curOff, err := f.Seek(<span class="number">0</span>, os.SEEK_CUR)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从当前文件的末尾处，移动至 +sizeInBytes 位置处，返回 offset</span></span><br><span class="line"><span class="comment">// 一般 size = 067108864</span></span><br><span class="line"><span class="comment">// 即 sizeInBytes 的值 64 * 1024 *1024</span></span><br><span class="line">size, err := f.Seek(sizeInBytes, os.SEEK_END)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移动回文件之前的读写位置，待后续写入</span></span><br><span class="line"><span class="keyword">if</span> _, err = f.Seek(curOff, os.SEEK_SET); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 已分配足够空间，返回 nil</span></span><br><span class="line"><span class="comment">// 一般 sizeInBytes == size</span></span><br><span class="line"><span class="keyword">if</span> sizeInBytes &gt; size &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多分配了空间，以 sizeInBytes 截断文件</span></span><br><span class="line"><span class="comment">// truncate 之后，文件大小才显示为 sizeInBytes 大小</span></span><br><span class="line"><span class="keyword">return</span> f.Truncate(sizeInBytes)</span><br></pre></td></tr></table></figure>

<p>在 darwin OS 上，首先会调用 preallocFixed，该函数中使用了系统调用 SYS_FCNTL 预先分配文件空间</p>
<p>如果 preallocFixed 失败，则调用 preallocExtendTrunc 再次尝试分配</p>
<h1 id="编码-解码"><a href="#编码-解码" class="headerlink" title="编码 / 解码"></a>编码 / 解码</h1><p>wal/encoder.go 实现了写入逻辑<br>wal/decoder.go 实现了读取逻辑</p>
<h1 id="File-Pipeline"><a href="#File-Pipeline" class="headerlink" title="File Pipeline"></a>File Pipeline</h1><p>wal/file_pipeline.go 用来预创建文件，为后续生成新的 wal 文件使用</p>
<p>fp.Open() 在 cut 方法中被调用，cut 中的调用如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a temp wal file with name sequence + 1, or truncate the existing one</span></span><br><span class="line">newTail, err := w.fp.Open()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 fp.Open() 从 fp.filec 中获取 locks file 返回</p>
<p>在初始化 file pipeline 方法 newFilePipeline 中启动 fp.run() 协程，查看 fp.run() 实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fp *filePipeline)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(fp.errc)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		f, err := fp.alloc()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fp.errc &lt;- err</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// fp.filec 大小为 1</span></span><br><span class="line">		<span class="keyword">case</span> fp.filec &lt;- f:</span><br><span class="line">		<span class="keyword">case</span> &lt;-fp.donec:</span><br><span class="line">			os.Remove(f.Name())</span><br><span class="line">			f.Close()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 fp.alloc() 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fp *filePipeline)</span> <span class="title">alloc</span><span class="params">()</span> <span class="params">(f *fileutil.LockedFile, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// count % 2 so this file isn&#x27;t the same as the one last published</span></span><br><span class="line">	fpath := filepath.Join(fp.dir, fmt.Sprintf(<span class="string">&quot;%d.tmp&quot;</span>, fp.count%<span class="number">2</span>))</span><br><span class="line">	<span class="keyword">if</span> f, err = fileutil.LockFile(fpath, os.O_CREATE|os.O_WRONLY, fileutil.PrivateFileMode); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err = fileutil.Preallocate(f.File, fp.size, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		plog.Errorf(<span class="string">&quot;failed to allocate space when creating new wal file (%v)&quot;</span>, err)</span><br><span class="line">		f.Close()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	fp.count++</span><br><span class="line">	<span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见预生成了 [0-1].tmp 文件，并对该文件加了锁，待调用 fp.Open() 方法获取使用</p>
<h1 id="Cut-方法"><a href="#Cut-方法" class="headerlink" title="Cut 方法"></a>Cut 方法</h1><p>wal 文件大小上限为 64MB</p>
<p>因此当写入消息之后， wal 文件大小 &gt; 64MB 时，会调用 cut 方法</p>
<p>截断之前的 wal 文件，并生成新的 wal 文件用于写入</p>
<p>cut 的整体思路</p>
<ol>
<li>截断当前使用的 wal 文件</li>
<li>从 file pipeline 中获取 tmp 文件</li>
<li>向 tmp 文件中写入必要的 headers</li>
<li>将 tmp 文件 rename to wal 文件，新文件名为 walName(w.seq()+1, w.enti+1)</li>
<li>将新 wal 文件加入 locks slice 中，并生成 newFileEncoder 用于写入新 wal 文件</li>
</ol>
<p>详细阅读 cut 方法（保留了原注释）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cut closes current file written and creates a new one ready to append.</span></span><br><span class="line"><span class="comment">// cut first creates a temp wal file and writes necessary headers into it.</span></span><br><span class="line"><span class="comment">// Then cut atomically rename temp wal file to a wal file.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WAL)</span> <span class="title">cut</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">       <span class="comment">// close old wal file; truncate to avoid wasting space if an early cut</span></span><br><span class="line">       <span class="comment">// 从 locks slice 中取最后一个 file</span></span><br><span class="line">       <span class="comment">// seek 到当前读写位置</span></span><br><span class="line">       off, serr := w.tail().Seek(<span class="number">0</span>, os.SEEK_CUR)</span><br><span class="line">       <span class="keyword">if</span> serr != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> serr</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 截断至当前读写位置</span></span><br><span class="line">       <span class="keyword">if</span> err := w.tail().Truncate(off); err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 系统调用 fsync 落盘</span></span><br><span class="line">       <span class="keyword">if</span> err := w.sync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">	   </span><br><span class="line">       <span class="comment">// 生成新的 wal 文件名</span></span><br><span class="line">       <span class="comment">// seq + 1</span></span><br><span class="line">       <span class="comment">// index + 1</span></span><br><span class="line">       fpath := filepath.Join(w.dir, walName(w.seq()+<span class="number">1</span>, w.enti+<span class="number">1</span>))</span><br><span class="line">       <span class="comment">// create a temp wal file with name sequence + 1, or truncate the existing one</span></span><br><span class="line">       <span class="comment">// 从 filePipeline 中获取预创建好的 [0-1].tmp 文件</span></span><br><span class="line">       newTail, err := w.fp.Open()</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// update writer and save the previous crc</span></span><br><span class="line">       <span class="comment">// 添加至 locks slice 末尾</span></span><br><span class="line">       w.locks = <span class="built_in">append</span>(w.locks, newTail)</span><br><span class="line">       prevCrc := w.encoder.crc.Sum32()</span><br><span class="line">       w.encoder, err = newFileEncoder(w.tail().File, prevCrc)</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 写入之前 wal 的 crc</span></span><br><span class="line">       <span class="keyword">if</span> err = w.saveCrc(prevCrc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 写入 metadata</span></span><br><span class="line">       <span class="keyword">if</span> err = w.encoder.encode(&amp;walpb.Record&#123;Type: metadataType, Data: w.metadata&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 写入 raft HardState</span></span><br><span class="line">       <span class="keyword">if</span> err = w.saveState(&amp;w.state); err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// atomically move temp wal file to wal file</span></span><br><span class="line">       <span class="comment">// fsync 落盘</span></span><br><span class="line">       <span class="keyword">if</span> err = w.sync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">		</span><br><span class="line">       <span class="comment">// 获取当前位置 offset</span></span><br><span class="line">       off, err = w.tail().Seek(<span class="number">0</span>, os.SEEK_CUR)</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 同一个文件系统相当于 mv</span></span><br><span class="line">       <span class="keyword">if</span> err = os.Rename(newTail.Name(), fpath); err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// fsync 父目录</span></span><br><span class="line">       <span class="keyword">if</span> err = fileutil.Fsync(w.dirFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">	   </span><br><span class="line">       <span class="comment">// 关闭 filePipeline 打开的 newTail</span></span><br><span class="line">       newTail.Close()</span><br><span class="line">		</span><br><span class="line">       <span class="comment">// 重新加锁</span></span><br><span class="line">       <span class="keyword">if</span> newTail, err = fileutil.LockFile(fpath, os.O_WRONLY, fileutil.PrivateFileMode); err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// off, err = w.tail().Seek(0, os.SEEK_CUR)</span></span><br><span class="line">       <span class="comment">// 重新设置下次读写位置为当前位置</span></span><br><span class="line">       <span class="keyword">if</span> _, err = newTail.Seek(off, os.SEEK_SET); err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">       w.locks[<span class="built_in">len</span>(w.locks)<span class="number">-1</span>] = newTail</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 莫名，直接使用之前的 prevCrc 不可以么</span></span><br><span class="line">       prevCrc = w.encoder.crc.Sum32()</span><br><span class="line">       w.encoder, err = newFileEncoder(w.tail().File, prevCrc)</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">       plog.Infof(<span class="string">&quot;segmented wal file %v is created&quot;</span>, fpath)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 cut 方法初始写入 wal 的内容示意如下</p>
<p><img src="/images/cut_wal.jpeg" alt="cut_wal"></p>
<h1 id="Sync-方法"><a href="#Sync-方法" class="headerlink" title="Sync 方法"></a>Sync 方法</h1><p>在 wal 中有如下几个地方使用了 sync 方法</p>
<ol>
<li>func (w *WAL) Save(st raftpb.HardState, ents []raftpb.Entry) error {}</li>
<li>func (w *WAL) cut() error {}</li>
<li>func (w *WAL) SaveSnapshot(e walpb.Snapshot) error {}</li>
<li>func (w *WAL) Close() error {}</li>
</ol>
<p>sync 直接来说是使用了系统调用 fsync，确保数据写入磁盘持久化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WAL)</span> <span class="title">sync</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> w.encoder != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := w.encoder.flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 记录开始时间</span></span><br><span class="line">	start := time.Now()</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 底层是系统调用</span></span><br><span class="line">	err := fileutil.Fdatasync(w.tail().File)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算 fsync 耗时</span></span><br><span class="line">	duration := time.Since(start)</span><br><span class="line">	<span class="comment">// 大于 1s 告警</span></span><br><span class="line">	<span class="keyword">if</span> duration &gt; warnSyncDuration &#123;</span><br><span class="line">		plog.Warningf(<span class="string">&quot;sync duration of %v, expected less than %v&quot;</span>, duration, warnSyncDuration)</span><br><span class="line">	&#125;</span><br><span class="line">	syncDurations.Observe(duration.Seconds())</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看下 func (w *WAL) Save(st raftpb.HardState, ents []raftpb.Entry) error 方法，毕竟它调用频率较高</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WAL)</span> <span class="title">Save</span><span class="params">(st raftpb.HardState, ents []raftpb.Entry)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	mustSync := mustSync(st, w.state, <span class="built_in">len</span>(ents))</span><br><span class="line">	<span class="comment">//func mustSync(st, prevst raftpb.HardState, entsnum int) bool &#123;</span></span><br><span class="line">	<span class="comment">//	return entsnum != 0 || st.Vote != prevst.Vote || st.Term != prevst.Term</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	...</span><br><span class="line">	curOff, err := w.tail().Seek(<span class="number">0</span>, os.SEEK_CUR)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> curOff &lt; SegmentSizeBytes &#123;</span><br><span class="line">		<span class="keyword">if</span> mustSync &#123;</span><br><span class="line">			<span class="keyword">return</span> w.sync()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> w.cut()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上： vote / term 变化，或有 entries 要写入时，调用 w.sync</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2007 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zrss</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">226k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:26</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
















  <script>
    NProgress.configure({
      showSpinner: true
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>


  








  

  

</body>
</html>
